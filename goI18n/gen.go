package main

import (
	"bytes"
	"fmt"
	"github.com/eliassama/go-i18n/core"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func generateGoFile(i18nBundles map[string]*core.Bundle, outputDir, i18nPkgName, defaultLanguageCode string, statusExist, codeExist bool) {

	const tmpl = `// Package {{ .PkgName }} Code generated by go generate; DO NOT EDIT. Please adjust your TOML file to regenerate.
package {{ .PkgName }}
{{ if .UseImports }}
import (
	"bytes"
	i18ncore "github.com/eliassama/go-i18n/core"
	"golang.org/x/text/language"
	"strings"
	"text/template"
)
{{- else }}
import (
	i18ncore "github.com/eliassama/go-i18n/core"
	"golang.org/x/text/language"
	"strings"
)
{{ end }}

var Msg = struct {
	{{- range $key, $value := .I18nBundles }}
	{{ $key }} *i18ncore.Bundle
	{{- end }}
}{
	{{- range $key, $value := .I18nBundles }}
	{{ $key }}: &i18ncore.Bundle{
		Status:   {{ $value.Status }},
		Code:     {{ $value.Code }},
		Plural:   map[string]string{
			{{- range $k, $v := $value.Plural }}
			"{{ $k }}": {{ printf "%q" $v }},
			{{- end }}
		},
		Singular: map[string]string{
			{{- range $k, $v := $value.Singular }}
			"{{ $k }}": {{ printf "%q" $v }},
			{{- end }}
		},
		Msg: map[string]string{
			{{- range $k, $v := $value.Msg }}
			"{{ $k }}": {{ printf "%q" $v }},
			{{- end }}
		},
	},
	{{- end }}
}

{{ range $key, $value := .I18nBundles }}
{{- $structName := printf "%sParams" $key }}
{{- if or (containsTemplate $value.Plural) (containsTemplate $value.Singular) (containsTemplate $value.Msg) }}
// {{ $structName }} is the parameter struct for the Send{{ $key }} method
type {{ $structName }} struct {
	{{- $params := collectParams $value }}
	{{- range $param := $params }}
	{{ $param }} string
	{{- end }}
}
{{- end }}

{{- if or (containsTemplate $value.Plural) (containsTemplate $value.Singular) (containsTemplate $value.Msg) }}
func Send{{ $key }}(langCode string{{ if or (len $value.Plural) (len $value.Singular) }}, count int{{ end }}, params {{ $structName }}) {{ if $.CodeExist }}(int{{ if $.StatusExist }}, int{{ end }}, string, error){{ else if $.StatusExist }}(int, string, error){{ else }}(string, error){{ end }} {
	bundle := Msg.{{ $key }}
	langCode = convertLangCode(langCode)

	var msg string

	{{- if (len $value.Plural) }}
	if count > 1 {
		msg = bundle.Plural[langCode]
		if msg == "" {
			msg = bundle.Plural["{{ $.DefaultLanguageCode }}"]
		}
	} else {
		msg = bundle.Singular[langCode]
		if msg == "" {
			msg = bundle.Singular["{{ $.DefaultLanguageCode }}"]
		}
		if msg == "" {
			msg = bundle.Msg[langCode]
			if msg == "" {
				msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
			}
		}
	}
	{{- else if (len $value.Singular) }}
	msg = bundle.Singular[langCode]
	if msg == "" {
		msg = bundle.Singular["{{ $.DefaultLanguageCode }}"]
	}
	if msg == "" {
		msg = bundle.Msg[langCode]
		if msg == "" {
			msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
		}
	}
	{{- else }}
	msg = bundle.Msg[langCode]
	if msg == "" {
		msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
	}
	{{- end }}

	tmpl, err := template.New("message").Parse(msg)
	if err != nil {
		return {{ if $.CodeExist }}0{{ if $.StatusExist }}, 0{{ end }}, "", err{{ else if $.StatusExist }}0, "", err{{ else }}"", err{{ end }}
	}
	var buf bytes.Buffer
	if err = tmpl.Execute(&buf, params); err != nil {
		return {{ if $.CodeExist }}0{{ if $.StatusExist }}, 0{{ end }}, "", err{{ else if $.StatusExist }}0, "", err{{ else }}"", err{{ end }}
	}
	return {{ if $.CodeExist }}bundle.Code{{ if $.StatusExist }}, bundle.Status{{ end }}, buf.String(), nil{{ else if $.StatusExist }}bundle.Status, buf.String(), nil{{ else }}buf.String(), nil{{ end }}
}
{{- else }}
func Send{{ $key }}(langCode string{{ if or (len $value.Plural) (len $value.Singular) }}, count int{{ end }}) {{ if $.CodeExist }}(int{{ if $.StatusExist }}, int{{ end }}, string){{ else if $.StatusExist }}(int, string){{ else }}(string){{ end }} {
	bundle := Msg.{{ $key }}
	langCode = convertLangCode(langCode)

	var msg string

	{{- if (len $value.Plural) }}
	if count > 1 {
		msg = bundle.Plural[langCode]
		if msg == "" {
			msg = bundle.Plural["{{ $.DefaultLanguageCode }}"]
		}
	} else {
		msg = bundle.Singular[langCode]
		if msg == "" {
			msg = bundle.Singular["{{ $.DefaultLanguageCode }}"]
		}
		if msg == "" {
			msg = bundle.Msg[langCode]
			if msg == "" {
				msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
			}
		}
	}
	{{- else if (len $value.Singular) }}
	msg = bundle.Singular[langCode]
	if msg == "" {
		msg = bundle.Singular["{{ $.DefaultLanguageCode }}"]
	}
	if msg == "" {
		msg = bundle.Msg[langCode]
		if msg == "" {
			msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
		}
	}
	{{- else }}
	msg = bundle.Msg[langCode]
	if msg == "" {
		msg = bundle.Msg["{{ $.DefaultLanguageCode }}"]
	}
	{{- end }}

	return {{ if $.CodeExist }}bundle.Code{{ if $.StatusExist }}, bundle.Status{{ end }}, msg{{ else if $.StatusExist }}bundle.Status, msg{{ else }}msg{{ end }}
}
{{- end }}
{{- end }}

func convertLangCode(langCode string) string {
	if langTag, err := language.Parse(langCode); err != nil {
		return ""
	} else {
		return strings.ToLower(langTag.String())
	}
}
`

	funcMap := template.FuncMap{
		"containsTemplate": containsTemplate,
		"collectParams":    collectParams,
	}

	useImports := false
	for _, bundle := range i18nBundles {
		if containsTemplate(bundle.Plural) || containsTemplate(bundle.Singular) || containsTemplate(bundle.Msg) {
			useImports = true
			break
		}
	}

	t := template.Must(template.New("go-tmpl").Funcs(funcMap).Parse(tmpl))
	var buf bytes.Buffer
	data := struct {
		PkgName             string
		I18nBundles         map[string]*core.Bundle
		UseImports          bool
		StatusExist         bool
		CodeExist           bool
		DefaultLanguageCode string
	}{
		PkgName:             i18nPkgName,
		I18nBundles:         i18nBundles,
		UseImports:          useImports,
		StatusExist:         statusExist,
		CodeExist:           codeExist,
		DefaultLanguageCode: defaultLanguageCode,
	}
	if err := t.Execute(&buf, data); err != nil {
		panic(fmt.Sprintf("Failed to execute template: %v", err))
	}

	outputFileName := strings.ToLower(i18nPkgName) + ".go"

	if err := os.WriteFile(filepath.Join(outputDir, outputFileName), buf.Bytes(), 0644); err != nil {
		panic(fmt.Sprintf("Failed to write file: %v", err))
	}
}

func containsTemplate(messages map[string]string) bool {
	tmplRegex := regexp.MustCompile(`{{.*}}`)
	for _, msg := range messages {
		if tmplRegex.MatchString(msg) {
			return true
		}
	}
	return false
}

func collectParams(bundle *core.Bundle) []string {
	paramSet := make(map[string]struct{})
	tmplRegex := regexp.MustCompile(`{{\s*\.([a-zA-Z0-9_]+)\s*}}`)

	for _, msg := range bundle.Plural {
		matches := tmplRegex.FindAllStringSubmatch(msg, -1)
		for _, match := range matches {
			if len(match) > 1 {
				paramSet[match[1]] = struct{}{}
			}
		}
	}

	for _, msg := range bundle.Singular {
		matches := tmplRegex.FindAllStringSubmatch(msg, -1)
		for _, match := range matches {
			if len(match) > 1 {
				paramSet[match[1]] = struct{}{}
			}
		}
	}

	for _, msg := range bundle.Msg {
		matches := tmplRegex.FindAllStringSubmatch(msg, -1)
		for _, match := range matches {
			if len(match) > 1 {
				paramSet[match[1]] = struct{}{}
			}
		}
	}

	params := make([]string, 0, len(paramSet))
	for param := range paramSet {
		params = append(params, param)
	}
	return params
}
